/** Declaration file generated by dts-gen */

declare module 'es-iter' {
  export = es_iter;
}

type IIter<T> = Iterable<T>;

declare class es_iter<I> {
  constructor(iterable: I[]);

  accumulate(callback: (x: any, y: any) => any): IIter<I>;

  chain(...iterables: Iterable<I>[]): IIter<I>;

  combinations(n: number): IIter<I>;

  compress(selectors: boolean[]): IIter<I>;

  drop(n: number): IIter<I>;

  dropWhile(callback: (x: any) => boolean): IIter<I>;

  enumerate(start: number): IIter<[number, I]>;

  filter(callback: (x: any) => boolean): IIter<I>;

  filterFalse(callback: (x: any) => boolean): IIter<I>;

  flatMap(callback: (x: any) => any, deep: boolean): IIter<I>;

  groupBy(key: (x: any) => any): IIter<I>;

  map(callback: (x: any) => any): IIter<I>;

  permutations(n: number): IIter<I>;

  product(arr: any[], ...iterables: Iterable<any>[]): IIter<any[]>;

  spreadMap(callback: (arr: any[]) => any): IIter<I>;

  take(n: number): IIter<I>;

  takeWhile(callback: (x: any) => any): IIter<I>;

  toArray(): I[];

  toIterator(): IIter<I>;

  static closeIterator<T>(iterator: Iterator<T>): boolean;

  static count(start: number, step: number): IIter<number>;

  static cycle<T>(iterable: Iterable<T>): IIter<T>;

  static entries<K, V>(obj: { [key: string]: V }): IIter<[K, V]>;

  static getIterator(obj: {}): Iterator<any>;

  static isClosable(iterator: Iterator<any>): boolean;

  static isIterable(obj: {} | null): boolean;

  static isIterator(obj: {}): boolean;

  static isMultiIterable(obj: Iterator<any>): boolean;

  static keys(obj: {}): IIter<any>;

  static longZip(
    iterable: Iterable<any>,
    ...iterables: Iterable<any>[]
  ): IIter<any[]>;

  static merge(
    iterable: Iterable<any>,
    iterable2: Iterable<any>,
    comparator: (a: any, b: any) => boolean,
  ): IIter<any>;

  static range(start: number, end: number, step: number): IIter<number>;

  static rangeRight(start: number, end: number, step: number): IIter<number>;

  static repeat<T>(val: T, times: number): IIter<T>;

  static reverse<T>(arr: T[]): IIter<T>;

  static values(obj: {}): IIter<any>;

  static zip(
    iterable: Iterable<any>,
    ...iterables: Iterable<any>[]
  ): Iterable<any[]>;
}

declare namespace Iter {
  function accumulate(...args: any[]): void;

  function chain(...args: any[]): void;

  function combinations(...args: any[]): void;

  function compress(...args: any[]): void;

  function drop(...args: any[]): void;

  function dropWhile(...args: any[]): void;

  function enumerate(...args: any[]): void;

  function filter(...args: any[]): void;

  function filterFalse(...args: any[]): void;

  function flatMap(...args: any[]): void;

  function groupBy(...args: any[]): void;

  function map(...args: any[]): void;

  function permutations(...args: any[]): void;

  function product(...args: any[]): void;

  function spreadMap(...args: any[]): void;

  function take(...args: any[]): void;

  function takeWhile(...args: any[]): void;

  function toArray(...args: any[]): void;

  function toIterator(...args: any[]): void;
}
